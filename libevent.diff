Index: sample/Makefile.am
===================================================================
--- sample/Makefile.am	(revision 310)
+++ sample/Makefile.am	(working copy)
@@ -1,6 +1,6 @@
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-LDADD = ../libevent.la
+LDADD = ../libevent.la ../libevhttp.la
 CPPFPLAGS = -I.. 
 CFLAGS = -I../compat
 
Index: http.c
===================================================================
--- http.c	(revision 310)
+++ http.c	(working copy)
@@ -54,6 +54,13 @@
 #include <netdb.h>
 #endif
 
+#define HAVE_OPENSSL 1 // XXX - replace with configure magic...
+#define OPENSSL_NO_KRB5	1
+#ifdef HAVE_OPENSSL
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#endif
+
 #include <assert.h>
 #include <ctype.h>
 #include <errno.h>
@@ -76,9 +83,15 @@
 #include "strlcpy-internal.h"
 #include "event.h"
 #include "evhttp.h"
+//#define USE_DEBUG 1
 #include "log.h"
 #include "http-internal.h"
 
+
+#ifdef HAVE_OPENSSL
+SSL_CTX	*evhttp_ssl_ctx;
+#endif
+
 #ifndef HAVE_GETADDRINFO
 struct addrinfo {
 	int ai_family;
@@ -125,9 +138,6 @@
 	struct evhttp_connection *evcon);
 static void evhttp_request_dispatch(struct evhttp_connection* evcon);
 
-void evhttp_read(int, short, void *);
-void evhttp_write(int, short, void *);
-
 #ifndef HAVE_STRSEP
 static char *
 strsep(char **s, const char *del)
@@ -240,23 +250,20 @@
 	}
 }
 
+#ifdef HAVE_OPENSSL
 void
-evhttp_write_buffer(struct evhttp_connection *evcon,
-    void (*cb)(struct evhttp_connection *, void *), void *arg)
+evhttp_ssl_init(void)
 {
-	event_debug(("%s: preparing to write buffer\n", __func__));
-
-	/* Set call back */
-	evcon->cb = cb;
-	evcon->cb_arg = arg;
-
-	/* check if the event is already pending */
-	if (event_pending(&evcon->ev, EV_WRITE|EV_TIMEOUT, NULL))
-		event_del(&evcon->ev);
-
-	event_set(&evcon->ev, evcon->fd, EV_WRITE, evhttp_write, evcon);
-	evhttp_add_event(&evcon->ev, evcon->timeout, HTTP_WRITE_TIMEOUT);
+	if (evhttp_ssl_ctx == NULL) {
+		SSL_load_error_strings();
+		SSL_library_init();
+		evhttp_ssl_ctx = SSL_CTX_new(SSLv23_method());
+		SSL_CTX_set_default_verify_paths(evhttp_ssl_ctx);
+		SSL_CTX_set_mode(evhttp_ssl_ctx,
+		    SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
+	}
 }
+#endif
 
 /*
  * Create the headers need for an HTTP reply
@@ -494,41 +501,6 @@
 }
 
 void
-evhttp_write(int fd, short what, void *arg)
-{
-	struct evhttp_connection *evcon = arg;
-	int n;
-
-	if (what == EV_TIMEOUT) {
-		evhttp_connection_fail(evcon, EVCON_HTTP_TIMEOUT);
-		return;
-	}
-
-	n = evbuffer_write(evcon->output_buffer, fd);
-	if (n == -1) {
-		event_warn("%s: evbuffer_write", __func__);
-		evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
-		return;
-	}
-
-	if (n == 0) {
-		event_warnx("%s: write nothing\n", __func__);
-		evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
-		return;
-	}
-
-	if (EVBUFFER_LENGTH(evcon->output_buffer) != 0) {
-		evhttp_add_event(&evcon->ev, 
-		    evcon->timeout, HTTP_WRITE_TIMEOUT);
-		return;
-	}
-
-	/* Activate our call back */
-	if (evcon->cb != NULL)
-		(*evcon->cb)(evcon, evcon->cb_arg);
-}
-
-void
 evhttp_connection_done(struct evhttp_connection *evcon)
 {
 	struct evhttp_request *req = TAILQ_FIRST(&evcon->requests);
@@ -577,6 +549,216 @@
 	}
 }
 
+void
+evhttp_connection_read(int fd, short what, void *arg)
+{
+	struct evhttp_connection *evcon = arg;
+	int n;
+
+	if (what == EV_TIMEOUT) {
+		evhttp_connection_fail(evcon, EVCON_HTTP_TIMEOUT);
+#ifdef HAVE_OPENSSL
+	} else if (evcon->ssl != NULL) {
+		u_char rbuf[4096];
+		int err;
+
+		do {
+			//printf("trying SSL_read\n");
+			n = SSL_read(evcon->ssl, rbuf, sizeof(rbuf));
+			err = SSL_get_error(evcon->ssl, n);
+			
+			if (err == SSL_ERROR_WANT_READ) {
+				//printf("SSL_read WANT_READ\n");
+				if (event_pending(&evcon->ev,
+					EV_READ|EV_WRITE|EV_TIMEOUT, NULL))
+					event_del(&evcon->ev);
+				event_set(&evcon->ev, evcon->fd, EV_READ,
+				    evhttp_connection_read, evcon);
+				evhttp_add_event(&evcon->ev, evcon->timeout,
+				    HTTP_READ_TIMEOUT);
+				return;
+			}
+			if (err == SSL_ERROR_WANT_WRITE) {
+				//printf("SSL_write WANT_WRITE\n");
+				if (event_pending(&evcon->ev,
+					EV_READ|EV_WRITE|EV_TIMEOUT, NULL))
+					event_del(&evcon->ev);
+				event_set(&evcon->ev, evcon->fd, EV_WRITE,
+				    evhttp_connection_read, evcon);
+				evhttp_add_event(&evcon->ev, evcon->timeout,
+				    HTTP_WRITE_TIMEOUT);
+				return;
+			}
+			if (err != SSL_ERROR_NONE) {
+				event_warnx("%s: bad SSL_read on %d: %s\n",
+				    __func__, fd,
+				    ERR_error_string(ERR_get_error(), NULL));
+				evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
+				return;
+			}
+			//printf("SSL_read of %d\n", n);
+			if (event_pending(&evcon->ev,
+				EV_READ|EV_WRITE|EV_TIMEOUT, NULL)) {
+				//printf("read event pending after completion!\n");
+				event_del(&evcon->ev);
+			}
+			evbuffer_add(evcon->input_buffer, rbuf, n);
+		} while (SSL_pending(evcon->ssl) > 0);
+		
+		if (evcon->cb != NULL) {
+			/* Activate our callback */
+			(*evcon->cb)(evcon, evcon->cb_arg);
+		}
+#endif
+	} else {
+		n = evbuffer_read(evcon->input_buffer, evcon->fd, -1);
+		event_debug(("%s: read %d on %d\n", __func__, n, evcon->fd));
+
+		if (n == -1) {
+			event_warn("%s: evbuffer_read", __func__);
+			evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
+		} else if (n == 0) {
+			/* Connection closed */
+			evhttp_connection_done(evcon);
+		} else if (evcon->cb != NULL) {
+			/* Activate our callback */
+			(*evcon->cb)(evcon, evcon->cb_arg);
+		}
+	}
+}
+	
+void
+evhttp_connection_write(int fd, short what, void *arg)
+{
+	struct evhttp_connection *evcon = arg;
+	int n;
+
+	if (what == EV_TIMEOUT) {
+		evhttp_connection_fail(evcon, EVCON_HTTP_TIMEOUT);
+#ifdef HAVE_OPENSSL
+	} else if (evcon->ssl != NULL) {
+		int err;
+
+		//printf("trying SSL_write of %ld on %d to %s:%d\n", EVBUFFER_LENGTH(evcon->output_buffer), evcon->fd, evcon->address, evcon->port);
+		n = SSL_write(evcon->ssl, EVBUFFER_DATA(evcon->output_buffer),
+		    EVBUFFER_LENGTH(evcon->output_buffer));
+		
+		err = SSL_get_error(evcon->ssl, n);
+		
+		if (err == SSL_ERROR_WANT_READ) {
+			//printf("SSL_write WANT_READ\n");
+			if (event_pending(&evcon->ev,
+				EV_READ|EV_WRITE|EV_TIMEOUT, NULL))
+				event_del(&evcon->ev);
+			event_set(&evcon->ev, evcon->fd, EV_READ,
+			    evhttp_connection_write, evcon);
+			evhttp_add_event(&evcon->ev, evcon->timeout,
+			    HTTP_READ_TIMEOUT);
+		} else if (err == SSL_ERROR_WANT_WRITE) {
+			//printf("SSL_write WANT_WRITE\n");
+			if (event_pending(&evcon->ev,
+				EV_READ|EV_WRITE|EV_TIMEOUT, NULL))
+				event_del(&evcon->ev);
+			event_set(&evcon->ev, evcon->fd, EV_READ|EV_WRITE,
+			    evhttp_connection_write, evcon);
+			evhttp_add_event(&evcon->ev, evcon->timeout,
+			    HTTP_WRITE_TIMEOUT);
+		} else if (err != SSL_ERROR_NONE) {
+			event_warnx("%s: bad SSL_write on %d: %d: %s\n",
+			    __func__, fd, err,
+			    ERR_error_string(ERR_get_error(), NULL));
+			evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
+		} else {
+			//printf("SSL_write %d of %ld\n", n, EVBUFFER_LENGTH(evcon->output_buffer));
+			assert(n == EVBUFFER_LENGTH(evcon->output_buffer));
+			evbuffer_drain(evcon->output_buffer, n);
+			if (event_pending(&evcon->ev,
+				EV_READ|EV_WRITE|EV_TIMEOUT, NULL)) {
+				//printf("write event pending after completion!\n");
+				event_del(&evcon->ev);
+			}
+			if (evcon->cb != NULL) {
+				/* Activate our call back */
+				(*evcon->cb)(evcon, evcon->cb_arg);
+			}
+		}
+#endif
+	} else {
+		n = evbuffer_write(evcon->output_buffer, fd);
+		
+		if (n == -1) {
+			event_warn("%s: evbuffer_write failed", __func__);
+			evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
+		} else if (n == 0) {
+			event_warnx("%s: write nothing\n", __func__);
+			evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
+		} else if (EVBUFFER_LENGTH(evcon->output_buffer) != 0) {
+			/* more to write */
+			event_set(&evcon->ev, evcon->fd, EV_WRITE,
+			    evhttp_connection_write, evcon);
+			evhttp_add_event(&evcon->ev, 
+			    evcon->timeout, HTTP_WRITE_TIMEOUT);
+		} else if (evcon->cb != NULL) {
+			/* Activate our call back */
+			(*evcon->cb)(evcon, evcon->cb_arg);
+		}
+	}
+}
+
+void
+evhttp_read(struct evhttp_connection *evcon,
+    void (*cb)(struct evhttp_connection *, void *), void *arg)
+{
+	event_debug(("%s: evhttp_read on %d\n", __func__, evcon->fd));
+
+	/* Set call back */
+	evcon->cb = cb;
+	evcon->cb_arg = arg;
+
+#ifdef HAVE_OPENSSL
+	/* SSL engine needs to drive our events. */
+	if (evcon->ssl != NULL) {
+		evhttp_connection_read(evcon->fd, EV_READ, evcon);
+		return;
+	}
+#endif
+	/* check if the event is already pending */
+	if (event_pending(&evcon->ev, EV_READ|EV_WRITE|EV_TIMEOUT, NULL))
+		event_del(&evcon->ev);
+
+	event_set(&evcon->ev, evcon->fd, EV_READ,
+	    evhttp_connection_read, evcon);
+	evhttp_add_event(&evcon->ev, evcon->timeout, HTTP_READ_TIMEOUT);
+}
+
+void
+evhttp_write(struct evhttp_connection *evcon,
+    void (*cb)(struct evhttp_connection *, void *), void *arg)
+{
+	event_debug(("%s: evhttp_write on %d of %d bytes\n",
+			__func__, evcon->fd,
+			EVBUFFER_LENGTH(evcon->output_buffer)));
+
+	/* Set call back */
+	evcon->cb = cb;
+	evcon->cb_arg = arg;
+
+#ifdef HAVE_OPENSSL
+	/* SSL engine needs to drive our events. */
+	if (evcon->ssl != NULL) {
+		evhttp_connection_write(evcon->fd, EV_WRITE, evcon);
+		return;
+	}
+#endif
+	/* check if the event is already pending */
+	if (event_pending(&evcon->ev, EV_READ|EV_WRITE|EV_TIMEOUT, NULL))
+		event_del(&evcon->ev);
+
+	event_set(&evcon->ev, evcon->fd, EV_WRITE,
+	    evhttp_connection_write, evcon);
+	evhttp_add_event(&evcon->ev, evcon->timeout, HTTP_WRITE_TIMEOUT);
+}
+
 /*
  * Handles reading from a chunked request.
  * return 1: all data has been read
@@ -608,17 +790,22 @@
 				/* Last chunk */
 				return (1);
 			}
-		} else if (len >= req->ntoread) {
-			/* Completed chunk */
-			evbuffer_add(req->input_buffer,
-			    EVBUFFER_DATA(buf), req->ntoread);
-			evbuffer_drain(buf, req->ntoread);
-			req->ntoread = -1;
-			if (req->cb != NULL) {
-				(*req->cb)(req, req->cb_arg);
-				/* XXX(niels): not sure if i like semantics */ 
-				evbuffer_drain(req->input_buffer,
-				    EVBUFFER_LENGTH(req->input_buffer));
+		} else {
+			int n = MIN(req->ntoread, len);
+			
+			evbuffer_add(req->input_buffer, EVBUFFER_DATA(buf), n);
+			evbuffer_drain(buf, n);
+			req->ntoread -= n;
+			
+			if (req->ntoread == 0) {
+				/* Completed chunk */
+				if (req->cb != NULL) {
+					(*req->cb)(req, req->cb_arg);
+					/* XXX(niels): not sure if i like semantics */ 
+					evbuffer_drain(req->input_buffer,
+					    EVBUFFER_LENGTH(req->input_buffer));
+				}
+				req->ntoread = -1;
 			}
 		}
 	}
@@ -627,8 +814,9 @@
 }
 
 void
-evhttp_read_body(struct evhttp_connection *evcon, struct evhttp_request *req)
+evhttp_read_body(struct evhttp_connection *evcon, void *arg)
 {
+	struct evhttp_request *req = arg;
 	struct evbuffer *buf = evcon->input_buffer;
 	
 	if (req->chunked) {
@@ -646,68 +834,23 @@
 	} else if (req->ntoread < 0) {
 		/* Read until connection close. */
 		evbuffer_add_buffer(req->input_buffer, buf);
-	} else if (EVBUFFER_LENGTH(buf) >= req->ntoread) {
-		/* Completed content length */
-		evbuffer_add(req->input_buffer, EVBUFFER_DATA(buf),
-		    req->ntoread);
-		evbuffer_drain(buf, req->ntoread);
-		req->ntoread = 0;
-		evhttp_connection_done(evcon);
-		return;
-	}
-	/* Read more! */
-	event_set(&evcon->ev, evcon->fd, EV_READ, evhttp_read, evcon);
-	evhttp_add_event(&evcon->ev, evcon->timeout, HTTP_READ_TIMEOUT);
-}
+	} else {
+		int n = MIN(req->ntoread, EVBUFFER_LENGTH(buf));
 
-/*
- * Reads data into a buffer structure until no more data
- * can be read on the file descriptor or we have read all
- * the data that we wanted to read.
- * Execute callback when done.
- */
+		evbuffer_add(req->input_buffer, EVBUFFER_DATA(buf), n);
+		evbuffer_drain(buf, n);
+		req->ntoread -= n;
 
-void
-evhttp_read(int fd, short what, void *arg)
-{
-	struct evhttp_connection *evcon = arg;
-	struct evhttp_request *req = TAILQ_FIRST(&evcon->requests);
-	struct evbuffer *buf = evcon->input_buffer;
-	int n, len;
-
-	if (what == EV_TIMEOUT) {
-		evhttp_connection_fail(evcon, EVCON_HTTP_TIMEOUT);
-		return;
+		if (req->ntoread == 0) {
+			/* Completed content length */
+			evhttp_connection_done(evcon);
+			return;
+		}
 	}
-	n = evbuffer_read(buf, fd, -1);
-	len = EVBUFFER_LENGTH(buf);
-	event_debug(("%s: got %d on %d\n", __func__, n, fd));
-	
-	if (n == -1) {
-		event_warn("%s: evbuffer_read", __func__);
-		evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
-		return;
-	} else if (n == 0) {
-		/* Connection closed */
-		evhttp_connection_done(evcon);
-		return;
-	}
-	evhttp_read_body(evcon, req);
+	/* Read more! */
+	evhttp_read(evcon, evhttp_read_body, req);
 }
 
-void
-evhttp_write_connectioncb(struct evhttp_connection *evcon, void *arg)
-{
-	/* This is after writing the request to the server */
-	struct evhttp_request *req = TAILQ_FIRST(&evcon->requests);
-	assert(req != NULL);
-
-	/* We are done writing our header and are now expecting the response */
-	req->kind = EVHTTP_RESPONSE;
-
-	evhttp_start_read(evcon);
-}
-
 /*
  * Clean up a connection object
  */
@@ -740,9 +883,13 @@
 	if (event_initialized(&evcon->ev))
 		event_del(&evcon->ev);
 	
-	if (evcon->fd != -1)
+	if (evcon->fd != -1) {
+#ifdef HAVE_OPENSSL
+		if (evcon->ssl != NULL)
+			SSL_free(evcon->ssl);
+#endif
 		close(evcon->fd);
-
+	}
 	if (evcon->address != NULL)
 		free(evcon->address);
 
@@ -755,27 +902,6 @@
 	free(evcon);
 }
 
-static void
-evhttp_request_dispatch(struct evhttp_connection* evcon)
-{
-	struct evhttp_request *req = TAILQ_FIRST(&evcon->requests);
-	
-	/* this should not usually happy but it's possible */
-	if (req == NULL)
-		return;
-
-	/* delete possible close detection events */
-	evhttp_connection_stop_detectclose(evcon);
-	
-	/* we assume that the connection is connected already */
-	assert(evcon->state == EVCON_CONNECTED);
-
-	/* Create the header from the store arguments */
-	evhttp_make_header(evcon, req);
-
-	evhttp_write_buffer(evcon, evhttp_write_connectioncb, NULL);
-}
-
 /* Reset our connection state */
 void
 evhttp_connection_reset(struct evhttp_connection *evcon)
@@ -801,15 +927,21 @@
 evhttp_detect_close_cb(int fd, short what, void *arg)
 {
 	struct evhttp_connection *evcon = arg;
+
 	evhttp_connection_reset(evcon);
 }
 
 static void
 evhttp_connection_start_detectclose(struct evhttp_connection *evcon)
 {
+#ifdef HAVE_OPENSSL
+	/* XXX - how to support this, when SSL can renegotiate at any time? */
+	if (evcon->ssl != NULL)
+		return;
+#endif
 	evcon->flags |= EVHTTP_CON_CLOSEDETECT;
 
-	if (event_initialized(&evcon->close_ev))
+	if (event_pending(&evcon->close_ev, EV_READ|EV_TIMEOUT, NULL))
 		event_del(&evcon->close_ev);
 	event_set(&evcon->close_ev, evcon->fd, EV_READ,
 	    evhttp_detect_close_cb, evcon);
@@ -819,6 +951,10 @@
 static void
 evhttp_connection_stop_detectclose(struct evhttp_connection *evcon)
 {
+#ifdef HAVE_OPENSSL
+	if (evcon->ssl != NULL)
+		return;
+#endif
 	evcon->flags &= ~EVHTTP_CON_CLOSEDETECT;
 	event_del(&evcon->close_ev);
 }
@@ -1154,133 +1290,87 @@
 	return (done);
 }
 
-static int
-evhttp_get_body_length(struct evhttp_request *req)
-{
-	struct evkeyvalq *headers = req->input_headers;
-	const char *content_length;
-	const char *connection;
-
-	content_length = evhttp_find_header(headers, "Content-Length");
-	connection = evhttp_find_header(headers, "Connection");
-		
-	if (content_length == NULL && connection == NULL)
-		req->ntoread = -1;
-	else if (content_length == NULL &&
-	    strcasecmp(connection, "Close") != 0) {
-		/* Bad combination, we don't know when it will end */
-		event_warnx("%s: we got no content length, but the "
-		    "server wants to keep the connection open: %s.\n",
-		    __func__, connection);
-		return (-1);
-	} else if (content_length == NULL) {
-		req->ntoread = -1;
-	} else {
-		char *endp;
-		req->ntoread = strtol(content_length, &endp, 10);
-		if (*content_length == '\0' || *endp != '\0') {
-			event_warnx("%s: illegal content length: %s",
-			    __func__, content_length);
-			return (-1);
-		}
-	}
-		
-	event_debug(("%s: bytes to read: %d (in buffer %d)\n",
-		__func__, req->ntoread,
-		EVBUFFER_LENGTH(evcon->input_buffer)));
-
-	return (0);
-}
-
 static void
-evhttp_get_body(struct evhttp_connection *evcon, struct evhttp_request *req)
+evhttp_read_header(struct evhttp_connection *evcon, void *arg)
 {
-	const char *xfer_enc;
-	
-	/* If this is a request without a body, then we are done */
-	if (req->kind == EVHTTP_REQUEST && req->type != EVHTTP_REQ_POST) {
-		evhttp_connection_done(evcon);
-		return;
-	}
-	xfer_enc = evhttp_find_header(req->input_headers, "Transfer-Encoding");
-	if (xfer_enc != NULL && strcasecmp(xfer_enc, "chunked") == 0) {
-		req->chunked = 1;
-		req->ntoread = -1;
-	} else {
-		if (evhttp_get_body_length(req) == -1) {
-			evhttp_connection_fail(evcon,
-			    EVCON_HTTP_INVALID_HEADER);
-			return;
-		}
-	}
-	evhttp_read_body(evcon, req);
-}
+	struct evhttp_request *req = arg;
+	const char *p;
+	int res;
 
-void
-evhttp_read_header(int fd, short what, void *arg)
-{
-	struct evhttp_connection *evcon = arg;
-	struct evhttp_request *req = TAILQ_FIRST(&evcon->requests);
-	int n, res;
-
-	if (what == EV_TIMEOUT) {
-		event_debug(("%s: timeout on %d\n", __func__, fd));
-		evhttp_connection_fail(evcon, EVCON_HTTP_TIMEOUT);
-		return;
-	}
-
-	n = evbuffer_read(evcon->input_buffer, fd, -1);
-	if (n == 0) {
-		event_warnx("%s: no more data on %d\n", __func__, fd);
-		evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
-		return;
-	}
-	if (n == -1) {
-		event_warnx("%s: bad read on %d\n", __func__, fd);
-		evhttp_connection_fail(evcon, EVCON_HTTP_EOF);
-		return;
-	}
-
 	res = evhttp_parse_lines(req, evcon->input_buffer);
+	
 	if (res == -1) {
 		/* Error while reading, terminate */
-		event_debug(("%s: bad header lines on %d\n", __func__, fd));
+		event_debug(("%s: bad header lines on %d\n", __func__,
+				evcon->fd));
 		evhttp_connection_fail(evcon, EVCON_HTTP_INVALID_HEADER);
 		return;
-	} else if (res == 0) {
+	}
+	if (res == 0) {
 		/* Need more header lines */
-		evhttp_add_event(&evcon->ev, 
-		    evcon->timeout, HTTP_READ_TIMEOUT);
+		evhttp_read(evcon, evhttp_read_header, req);
 		return;
 	}
-
 	/* Done reading headers, do the real work */
-	switch (req->kind) {
-	case EVHTTP_REQUEST:
-		event_debug(("%s: checking for post data on %d\n",
-				__func__, fd));
-		evhttp_get_body(evcon, req);
-		break;
-
-	case EVHTTP_RESPONSE:
+	if (req->kind == EVHTTP_REQUEST) {
+		if (req->type != EVHTTP_REQ_POST) {
+			evhttp_connection_done(evcon);
+			return;
+		}
+	} else if (req->kind == EVHTTP_RESPONSE) {
 		if (req->response_code == HTTP_NOCONTENT ||
 		    req->response_code == HTTP_NOTMODIFIED ||
 		    (req->response_code >= 100 && req->response_code < 200)) {
 			event_debug(("%s: skipping body for code %d\n",
 					__func__, req->response_code));
 			evhttp_connection_done(evcon);
-		} else {
-			event_debug(("%s: start of read body for %s on %d\n",
-				__func__, req->remote_host, fd));
-			evhttp_get_body(evcon, req);
+			return;
 		}
-		break;
-
-	default:
-		event_warnx("%s: bad header on %d\n", __func__, fd);
+	} else {
+		event_warnx("%s: bad header on %d\n", __func__, evcon->fd);
 		evhttp_connection_fail(evcon, EVCON_HTTP_INVALID_HEADER);
-		break;
+		return;
 	}
+	/* Determine length of entity body. */
+	req->ntoread = -1;
+	
+	if ((p = evhttp_find_header(req->input_headers,
+		 "Transfer-Encoding")) != NULL &&
+	    strcasecmp(p, "chunked") == 0) {
+		req->chunked = 1;
+	} else if ((p = evhttp_find_header(req->input_headers,
+			"Content-Length")) != NULL) {
+		char *endp;
+		req->ntoread = strtol(p, &endp, 10);
+		if (*p == '\0' || *endp != '\0') {
+			event_warnx("%s: illegal content length: %s",
+			    __func__, p);
+			evhttp_connection_fail(evcon,
+			    EVCON_HTTP_INVALID_HEADER);
+			return;
+		}
+	} else if ((p = evhttp_find_header(req->input_headers,
+			"Connection")) != NULL) {
+		if (strcasecmp(p, "Close") != 0) {
+			/* Bad combination, we don't know when it will end */
+			event_warnx("%s: we got no content length, but the "
+			    "server wants to keep the connection open: %s.\n",
+			    __func__, p);
+			evhttp_connection_fail(evcon,
+			    EVCON_HTTP_INVALID_HEADER);
+			return;
+		}
+	}
+	event_debug(("%s: start of read body (%d) for %s:%d on %d "
+			"(%d in buffer)\n",
+			__func__, req->ntoread, evcon->address,
+			evcon->port, evcon->fd,
+			EVBUFFER_LENGTH(evcon->input_buffer)));
+
+	if (EVBUFFER_LENGTH(evcon->input_buffer)) {
+		evhttp_read_body(evcon, req);
+	} else
+		evhttp_read(evcon, evhttp_read_body, req);
 }
 
 /*
@@ -1337,6 +1427,21 @@
 	return (NULL);
 }
 
+#ifdef HAVE_OPENSSL
+struct evhttp_connection *
+evhttp_connection_new_ssl(const char *address, unsigned short port)
+{
+	struct evhttp_connection *evcon = evhttp_connection_new(address, port);
+
+	evhttp_ssl_init();
+	
+	if (evcon != NULL) {
+		evcon->ssl = SSL_new(evhttp_ssl_ctx);
+	}
+	return (evcon);
+}
+#endif
+
 void
 evhttp_connection_set_timeout(struct evhttp_connection *evcon,
     int timeout_in_secs)
@@ -1385,7 +1490,12 @@
 		    __func__, evcon->address, evcon->port);
 		return (-1);
 	}
-
+#ifdef HAVE_OPENSSL
+	if (evcon->ssl != NULL) {
+		SSL_set_connect_state(evcon->ssl);
+		SSL_set_fd(evcon->ssl, evcon->fd);
+	}
+#endif
 	/* Set up a callback for successful connection setup */
 	event_set(&evcon->ev, evcon->fd, EV_WRITE, evhttp_connectioncb, evcon);
 	evhttp_add_event(&evcon->ev, evcon->timeout, HTTP_CONNECT_TIMEOUT);
@@ -1395,6 +1505,41 @@
 	return (0);
 }
 
+void
+evhttp_request_done(struct evhttp_connection *evcon, void *arg)
+{
+	/* This is after writing the request to the server */
+	struct evhttp_request *req = TAILQ_FIRST(&evcon->requests);
+	assert(req != NULL);
+
+	/* We are done writing our header and are now expecting the response */
+	req->kind = EVHTTP_RESPONSE;
+
+	evhttp_read(evcon, evhttp_read_header, req);
+}
+
+void
+evhttp_request_dispatch(struct evhttp_connection* evcon)
+{
+	struct evhttp_request *req = TAILQ_FIRST(&evcon->requests);
+	
+	/* this should not usually happy but it's possible */
+	if (req == NULL)
+		return;
+
+	/* delete possible close detection events */
+	evhttp_connection_stop_detectclose(evcon);
+	
+	/* we assume that the connection is connected already */
+	assert(evcon->state == EVCON_CONNECTED);
+
+	/* Create the header from the store arguments */
+	evhttp_make_header(evcon, req);
+
+	//printf("request_dispatch\n");
+	evhttp_write(evcon, evhttp_request_done, NULL);
+}
+
 /*
  * Starts an HTTP request on the provided evhttp_connection object.
  * If the connection object is not connected to the web server already,
@@ -1441,23 +1586,7 @@
 	return (0);
 }
 
-/*
- * Reads data from file descriptor into request structure
- * Request structure needs to be set up correctly.
- */
-
 void
-evhttp_start_read(struct evhttp_connection *evcon)
-{
-	/* Set up an event to read the headers */
-	if (event_initialized(&evcon->ev))
-		event_del(&evcon->ev);
-	event_set(&evcon->ev, evcon->fd, EV_READ, evhttp_read_header, evcon);
-	
-	evhttp_add_event(&evcon->ev, evcon->timeout, HTTP_READ_TIMEOUT);
-}
-
-void
 evhttp_send_done(struct evhttp_connection *evcon, void *arg)
 {
 	int need_close;
@@ -1467,9 +1596,10 @@
 	/* delete possible close detection events */
 	evhttp_connection_stop_detectclose(evcon);
 	
-	need_close = evhttp_is_connection_close(req->input_headers) ||
-	    evhttp_is_connection_close(req->output_headers);
-
+	need_close = (!(req->major == 1 && req->minor == 1) ||
+	    (evhttp_is_connection_close(req->input_headers) ||
+	     evhttp_is_connection_close(req->output_headers)));
+	
 	assert(req->flags & EVHTTP_REQ_OWN_CONNECTION);
 	evhttp_request_free(req);
 
@@ -1527,7 +1657,7 @@
 	/* Adds headers to the response */
 	evhttp_make_header(evcon, req);
 
-	evhttp_write_buffer(evcon, evhttp_send_done, NULL);
+	evhttp_write(evcon, evhttp_send_done, NULL);
 }
 
 void
@@ -1555,7 +1685,8 @@
 		req->chunked = 1;
 	}
 	evhttp_make_header(req->evcon, req);
-	evhttp_write_buffer(req->evcon, NULL, NULL);
+	//printf("send_reply_start\n");
+	evhttp_write(req->evcon, NULL, NULL);
 }
 
 void
@@ -1566,7 +1697,8 @@
 		    EVBUFFER_LENGTH(databuf));
 	}
 	evbuffer_add_buffer(req->evcon->output_buffer, databuf);
-	evhttp_write_buffer(req->evcon, NULL, NULL);
+	//printf("send_reply_chunk\n");
+	evhttp_write(req->evcon, NULL, NULL);
 }
 
 void
@@ -1574,9 +1706,10 @@
 {
 	struct evhttp_connection *evcon = req->evcon;
 
+	//printf("send_reply_end\n");
 	if (req->chunked) {
 		evbuffer_add(req->evcon->output_buffer, "0\r\n\r\n", 5);
-		evhttp_write_buffer(req->evcon, evhttp_send_done, NULL);
+		evhttp_write(req->evcon, evhttp_send_done, NULL);
 		req->chunked = 0;
 	} else if (!event_pending(&evcon->ev, EV_WRITE|EV_TIMEOUT, NULL)) {
 		/* let the connection know that we are done with the request */
@@ -1588,6 +1721,12 @@
 	}
 }
 
+int
+evhttp_connection_write_pending(struct evhttp_connection *evcon)
+{
+	return (EVBUFFER_LENGTH(evcon->output_buffer));
+}
+
 void
 evhttp_response_code(struct evhttp_request *req, int code, const char *reason)
 {
@@ -1616,7 +1755,7 @@
 	evhttp_send(req, databuf);
 }
 
-static const char uri_chars[256] = {
+const char uri_chars[256] = {
 	0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
 	0, 1, 0, 0, 1, 0, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
@@ -1729,7 +1868,6 @@
 		if (value == NULL)
 			goto error;
 
-		event_warnx("Got: %s -> %s\n", key, value);
 		evhttp_add_header(headers, key, value);
 	}
 
@@ -1860,6 +1998,36 @@
 	return (http);
 }
 
+#ifdef HAVE_OPENSSL
+struct evhttp *
+evhttp_start_ssl(const char *address, u_short port, const char *certfile)
+{
+	struct evhttp *http = evhttp_start(address, port);
+
+	evhttp_ssl_init();
+	
+	if (http != NULL) {
+		if ((http->ssl_ctx = SSL_CTX_new(SSLv23_method())) != NULL) {
+			if (SSL_CTX_use_certificate_file(http->ssl_ctx,
+				certfile, SSL_FILETYPE_PEM) == 1 &&
+			    SSL_CTX_use_PrivateKey_file(http->ssl_ctx,
+				certfile, SSL_FILETYPE_PEM) == 1 && 
+			    SSL_CTX_check_private_key(http->ssl_ctx) == 1) {
+				/* XXX - negotiate to only allow TLSv1 */
+				SSL_CTX_set_options(evhttp_ssl_ctx,
+				    SSL_OP_NO_SSLv2|SSL_OP_NO_SSLv3);
+				SSL_CTX_set_mode(evhttp_ssl_ctx,
+				    SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
+				return (http);
+			}
+		}
+		evhttp_free(http);
+		http = NULL;
+	}
+	return (http);
+}
+#endif
+
 void
 evhttp_free(struct evhttp* http)
 {
@@ -1881,7 +2049,10 @@
 		free(http_cb->what);
 		free(http_cb);
 	}
-	
+#ifdef HAVE_OPENSSL
+	if (http->ssl_ctx != NULL)
+		SSL_CTX_free(http->ssl_ctx);
+#endif
 	free(http);
 }
 
@@ -2048,7 +2219,7 @@
 		event_err(1, "%s: strdup", __func__);
 	req->remote_port = evcon->port;
 
-	evhttp_start_read(evcon);
+	evhttp_read(evcon, evhttp_read_header, req);
 	
 	return (0);
 }
@@ -2063,6 +2234,16 @@
 	if (evcon == NULL)
 		return;
 
+#ifdef HAVE_OPENSSL
+	if (http->ssl_ctx != NULL) {
+		if ((evcon->ssl = \
+			SSL_new(http->ssl_ctx)) != NULL) {
+			SSL_set_fd(evcon->ssl, evcon->fd);
+			SSL_set_accept_state(evcon->ssl);
+		} else
+			return;
+	}
+#endif
 	/* the timeout can be used by the server to close idle connections */
 	if (http->timeout != -1)
 		evhttp_connection_set_timeout(evcon, http->timeout);
Index: evhttp.h
===================================================================
--- evhttp.h	(revision 310)
+++ evhttp.h	(working copy)
@@ -66,6 +66,13 @@
 struct evhttp *evhttp_start(const char *address, u_short port);
 
 /*
+ * Start an HTTPS server on the specified address and port,
+ * using the specified PEM-encoded certificate / private key
+ */
+struct evhttp *evhttp_start_ssl(const char *address, u_short port,
+    const char *certfile);
+	
+/*
  * Free the previously create HTTP server.  Works only if no requests are
  * currently being served.
  */
@@ -159,6 +166,9 @@
 struct evhttp_connection *evhttp_connection_new(
 	const char *address, unsigned short port);
 
+struct evhttp_connection *evhttp_connection_new_ssl(
+	const char *address, unsigned short port);
+
 /* Frees an http connection */
 void evhttp_connection_free(struct evhttp_connection *evcon);
 
@@ -177,7 +187,10 @@
 /* Get the remote address and port associated with this connection. */
 void evhttp_connection_get_peer(struct evhttp_connection *evcon,
     char **address, u_short *port);
-
+	
+/* Get the number of bytes outstanding to be written on this connection. */
+int evhttp_connection_write_pending(struct evhttp_connection *evcon);
+	
 /* The connection gets ownership of the request */
 int evhttp_make_request(struct evhttp_connection *evcon,
     struct evhttp_request *req,
Index: http-internal.h
===================================================================
--- http-internal.h	(revision 310)
+++ http-internal.h	(working copy)
@@ -56,7 +56,10 @@
 	int timeout;			/* timeout in seconds for events */
 	int retry_cnt;			/* retry count */
 	int retry_max;			/* maximum number of retries */
-	
+
+#ifdef HAVE_OPENSSL
+	SSL *ssl;
+#endif
 	enum evhttp_connection_state state;
 
 	/* for server connections, the http server they are connected with */
@@ -89,6 +92,9 @@
 	TAILQ_HEAD(httpcbq, evhttp_cb) callbacks;
         struct evconq connections;
 
+#ifdef HAVE_OPENSSL
+	SSL_CTX *ssl_ctx;
+#endif
         int timeout;
 
 	void (*gencb)(struct evhttp_request *req, void *);
@@ -112,10 +118,9 @@
 int evhttp_parse_lines(struct evhttp_request *, struct evbuffer*);
 
 void evhttp_start_read(struct evhttp_connection *);
-void evhttp_read_header(int, short, void *);
 void evhttp_make_header(struct evhttp_connection *, struct evhttp_request *);
 
-void evhttp_write_buffer(struct evhttp_connection *,
+void evhttp_write(struct evhttp_connection *,
     void (*)(struct evhttp_connection *, void *), void *);
 
 /* response sending HTML the data in the buffer */
Index: test/Makefile.am
===================================================================
--- test/Makefile.am	(revision 310)
+++ test/Makefile.am	(working copy)
@@ -1,6 +1,6 @@
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-LDADD = ../libevent.la
+LDADD = ../libevent.la ../libevhttp.la -lssl -lcrypto
 CPPFPLAGS = -I.. 
 CFLAGS = -I../compat @CFLAGS@
 
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 310)
+++ Makefile.am	(working copy)
@@ -21,7 +21,7 @@
 	WIN32-Prj/libevent.dsw WIN32-Prj/signal_test/signal_test.dsp \
 	WIN32-Prj/time_test/time_test.dsp
 
-lib_LTLIBRARIES = libevent.la
+lib_LTLIBRARIES = libevent.la libevhttp.la
 
 if BUILD_WIN32
 
@@ -40,11 +40,16 @@
 endif
 
 libevent_la_SOURCES = event.c buffer.c evbuffer.c log.c event_tagging.c \
-	http.c evhttp.h http-internal.h evdns.c evdns.h evrpc.c strlcpy.c \
-	evrpc.h evrpc-internal.h strlcpy-internal.h $(SYS_SRC)
+	evdns.c evdns.h $(SYS_SRC)
+
 libevent_la_LIBADD = @LTLIBOBJS@ $(SYS_LIBS)
 libevent_la_LDFLAGS = -release @VERSION@ -version-info 1:3:0
 
+libevhttp_la_SOURCES = http.c evhttp.h http-internal.h \
+	evrpc.c evrpc.h evrpc-internal.h strlcpy.c strlcpy-internal.h $(SYS_SRC)
+libevhttp_la_LIBADD = @LTLIBOBJS@ $(SYS_LIBS)
+libevhttp_la_LDFLAGS = -release @VERSION@ -version-info 1:3:0
+
 include_HEADERS = event.h evhttp.h evdns.h
 
 INCLUDES = -Icompat $(SYS_INCLUDES)
